{"meta":{"title":"미누블로그","subtitle":"미누캉 삽질 연구소","description":"안뇽하세요","author":"강민우","url":"https://minukang.github.io"},"pages":[{"title":"About me","date":"2017-10-30T05:56:27.000Z","updated":"2017-11-30T06:00:11.654Z","comments":true,"path":"about/index.html","permalink":"https://minukang.github.io/about/index.html","excerpt":"","text":"FrontEnd 개발을 주로 하고 있는 강민우라고 합니다. 현재 2015년 10월 13일부터 2018년 8월 12일까지 국가의 부름을 받아 웹에이전시 디앤디랩에 산업기능요원로 재직을 하고 있습니다. 웹을 처음 접한 시기는 2012년 초 입니다. 그 때 부터 지금까지 계속 공부하고 있으며, 앞으로도 끊임없이 공부할거라 예상하고 있습니다. 자랑할 거리는 아니지만 기능경기대회라는 곳에서 웹사이트 디자인/개발 종목을 서울대표로 1등을 한 경험이 있으며, 전국에서 나름 이름을 알린 경력 아닌 경력이 있습니다. 주로 사용하는 언어는 자바스크립트입니다. HTML과 CSS는 올바르고 효율적으로 사용하고자 노력하고 있습니다. 업무상 PHP와 데이터베이스 쿼리를 작성해야할 경우도 생겨 잘하진 못하지만 기본적으로 알고있습니다. 최근에는 파이썬에 관심을 두고 있으며, 파이썬을 활용한 수학 공부랑 병행 중입니다. 참여 프로젝트2013년 미누 채팅 전체 디자인, 개발 2014년 한국청소년 동아리연맹 전체 디자인, 개발 2015년 레드윙코리아 PC 퍼블리싱 플랙진 PC 퍼블리싱, 모바일 퍼블리싱, 시스템 개발 헬스벨 CTI 연동 개발 사러가 PC 퍼블리싱, 시스템 개발 파타고니아 코리아 PC 퍼블리싱, 모바일 퍼블리싱, 시스템 개발 마켓컬리 PC 퍼블리싱, 모바일 퍼블리싱, 시스템 개발 2016년 라퀴진 모바일 모바일 퍼블리싱 EYEYE PC 퍼블리싱, 모바일 퍼블리싱, 시스템 개발 갈골한과 PC 퍼블리싱 두루약품 사이트 퍼블리싱, 차트 개발 한삼인몰 PC 퍼블리싱, 시스템 개발 일동몰 PC 퍼블리싱, 모바일 퍼블리싱, 시스템 개발 바이레다 인터렉션 개발, 브랜드 퍼블리싱 나트라케어 브랜드 퍼블리싱 농협홍삼 브랜드 퍼블리싱, 시스템 개발 2017년 제이에스티나 PC 퍼블리싱, 모바일 퍼블리싱 사조몰 모바일 퍼블리싱, 시스템 개발 디앤디랩 홈페이지 리뉴얼 반응형 퍼블리싱, 인터렉션 개발 사내 프로젝트 진행중! 감사합니다."}],"posts":[{"title":"문서 간에 통신하기 (X-Document-Messaging)","slug":"x-document-messaging","date":"2017-11-29T06:41:33.000Z","updated":"2017-11-29T10:22:52.256Z","comments":true,"path":"2017/11/29/x-document-messaging/","link":"","permalink":"https://minukang.github.io/2017/11/29/x-document-messaging/","excerpt":"","text":"웹 페이지에서 다른 사이트의 기능이나 위젯 등을 가져올 때 주로 iframe을 통해서 필요한 곳에 삽입하게 됩니다. 현재는 사장되어 가는 분위기지만 휴대폰 인증, 주소록 찾기, 아이디 중복확인 등 실시간으로 통신하기 귀찮은 것들을 따로 페이지로 만들어서 window.open 형태로 필요한 정보를 부모 페이지와 주고 받습니다. Browser Object Model (BOM)은 이를 제어 할 수 있는 프로퍼티를 주게됩니다. iframe 에서 삽입된 부모 페이지의 객체에 접근하기 위해 window.parent 를 제공합니다. window.open 에서 호출한 부모 페이지의 객체에 접근하기 위해 window.opener 를 제공합니다. 주의할 점은 window.parent는 삽입된 부모 페이지가 없으면 자기 자신을 가리킵니다. 일반적인 페이지에서 다음 식은 참이 되겠지요 12// 일반적인 페이지는 true, 아이프레임이 된 페이지는 falsereturn window.parent === window 하지만 window.opener는 호출 페이지가 없으면 undefined 를 가지게됩니다. 통신하는 방법원리는 간단합니다. iframe에서는 window.parent를, window.open에서는 window.opener 를 통해 부모 / 호출된 페이지의 객체에 접근하여 함수를 실행하든 직접 접근하든 실행하면됩니다. 12345678910&lt;!-- form.html --&gt;&lt;button type=\"button\" onclick=\"checkId()\"&gt;아이디 중복확인&lt;/button&gt;&lt;script&gt;function checkId () &#123; window.open(\"check_id.html\", \"\", \"width=400,height=500\")&#125;function checkIdSuccess (flag) &#123; // ....&#125;&lt;/script&gt; 아이디 중복확인 기능을 가진 폼 페이지입니다. 아이디 중복확인 기능을 따로 페이지를 만들어 window.open 을 통해 접근합니다. 1234567&lt;!-- check_id.html --&gt;&lt;button type=\"button\" onclick=\"useThisId()\"&gt;이 아이디 사용&lt;/button&gt;&lt;script&gt;function useThisId () &#123; window.opener.checkIdSuccess(true)&#125;&lt;/script&gt; 아이디 중복확인 페이지입니다. 호출 객체(window.opener)에 접근하여 해당 페이지에 있는 checkIdSuccess 함수를 실행합니다. iframe 에서는 위의 예제가 window.opener 대신 window.parent 로 접근하면 됩니다. Cross Origin Resource Sharing - CORS하지만 위의 통신 방법은 같은 도메인에서만 한정됩니다. BOM에 접근할 때 기본적으로 same-origin 정책을 따르기 때문에 다른 도메인에서 BOM에 접근 할 경우 아래와 같은 에러가 나오게됩니다. 이는 http://www.naver.com 에서 http://localhost:8080의 Cross Origin Resource Sharing (CORS) 를 허용하지 않았기 때문입니다. 다른 도메인을 가진 문서에 접근하고 싶으면 해당 문서의 관리자에게 ‘우리 도메인 허용해주세요!’ 라고 요청해야하는겁니다. 이러한 보안정책으로 인하여, 다른 문서에 접근하지 못하지만, 늘 그랬듯 방법이 아예 없는 것이 아닙니다. X-Document Messaging여기서 X-Document란 알수없는 문서를 가리킵니다. 이러한 알수없는 문서간의 통신에 대한 표준 API가 존재합니다. 이름하야 postMessage 입니다. 1otherWindow.postMessage(message, targetOrigin); postMessage 는 필요한 정보만 주고받아 메세지 형태로 발신하는 API입니다. 문법을 보면 otherWindow 는 통신하고자하는 BOM입니다. postMessage 는 CORS가 허용되지 않더라도 사용할 수 있는 API입니다. message 인자로 보내고자하는 내용을 보낼 수 있습니다. targetOrigin 은 현재 도메인 정보입니다. targetOrigin 를 통해 특정 도메인의 메시지만 받을 수 있도록 설정할 수 있습니다. 없더라도 명시를 해야하며, 이 경우 * 를 사용하면됩니다. 하지만 보안상의 이유로 명시하는 것이 좋습니다. 123456window.addEventListener('message', function (e) &#123; console.log('message', e.data) console.log('origin', e.origin) console.log('source', e.source) e.source.postMessage('다시 보내요!', 'http://localhost:8080')&#125;) message 이벤트는 메시지를 수신하고자하는 페이지에 설치하는 이벤트입니다. 첫번째 인자인 e 이벤트 객체를 통해 postMessage로 전송받은 값을 확인 할 수 있습니다. 전송내용은 e.data로, 도메인정보는 e.origin, 발신 객체는 e.source로 접근할 수 있습니다. e.source 를 통해 다시 발신 객체에게 수신 할 수 있습니다. 하위 브라우저 지원이러한 API는 확인 할 때는 IE 지원여부가 매우 중요하죠. 결론부터 말씀드리자면 IE8 부터 지원합니다. 하지만 IE아니랄까봐 제약사항이 있는데요. 모든 IE에서는 window.open 을 통한 cross-origin 통신이 불가합니다. IE에서는 명시적으로 8 ~ 9 만 postMessage API를 window.open에서 지원하지 않고, 그 이상의 버전에서는 지원을 하지만, 서로 도메인이 다를 경우 무응답을 하게됩니다. 다행히 iframe의 postMessage는 IE8부터 모두 사용할 수 있으니 그대로 사용하시면 됩니다. 요즘 개발 추세로는 window.open 을 통한 팝업 구현은 지양되고있으니, 이는 설계 단계에서 부터 자각하고 계시면됩니다. 또한 IE8-9에서는 postMessage의 메시지를 오로지 string으로만 보낼 수 있습니다. 이 하위 브라우저를 고려할 경우 JSON.stringify, JSON.parse를 통해 문자열로 바꿔서 보내고 발신자에서 오브젝트 형태로 써야합니다. window.open 의 IE 버그관련은 없지만 window.open을 IE에서 사용할 경우 몇가지 버그가 존재합니다. localhost 도메인에서 사용할 경우 opener가 분실된다.이 경우 127.0.0.1 을 사용하시면됩니다. 정말 골 때렸습니다. POST 데이터를 전달할 경우 새창이 아닌 현재창이 전송된다.window.open으로 페이지를 열 경우 기본적으로 GET 방식이지만 &lt;form&gt;의 target을 window.open 객체의 이름을 가르켜 POST 로 전달 할 수 있습니다. 12345678&lt;form id=\"f\" action=\"target.html\" target=\"newWindow\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"field\" value=\"1234\"&gt;&lt;/form&gt;&lt;script&gt;var form = document.getElementById('f')var newWindow = window.open('about:blank', 'newWindow', 'width=500,height=500')form.submit()&lt;/script&gt; window.open의 두번째 인자를 통해서 이름을 가질 수 있는데, 이것을 &lt;form&gt;의 target에 지정하게되면 해당 창을 가르키게됩니다. 하지만 IE에서 다른 도메인 간에 이렇게 전달할 경우 새 창이 아닌 현재 창이 전송되는 버그가 있습니다. 해결 방법은 localStorage로 폼 정보를 전달 후 새창을 열고 새창에서 폼을 만들어 전송하는 방법이 있습니다.","categories":[],"tags":[]},{"title":"무한대의 값을 프로그램에서 사용하기","slug":"infinite-value-in-program","date":"2017-11-02T12:19:04.000Z","updated":"2017-11-02T12:41:36.740Z","comments":true,"path":"2017/11/02/infinite-value-in-program/","link":"","permalink":"https://minukang.github.io/2017/11/02/infinite-value-in-program/","excerpt":"","text":"프로그램의 정수 개념중에 Infinite Number 라는 개념이 있습니다. 직역하자면 무한대의 숫자라는 뜻인데요. 처음 프로그래밍을 배울 때 접할 수 있지만 이것의 활용용도에 대해서 모호하고 예제 같은 것을 보기 힘들죠. 123456// Positive Infinityvar postive_inf1 = Infinityvar postive_inf2 = Number.POSITIVE_INFINITY// Negative Infinityvar negative_inf1 = -Infinityvar negative_inf2 = Number.NEGATIVE_INFINITY 자바스크립트에서 Infinite Number를 쓰는 예제입니다. Infinity 라는 예약어를 통해 +,-로 구분하여 사용할 수 있고, Number 객체의 상수로 접근하여 사용할 수 있습니다. 123console.log(Infinity &gt; 0) // trueconsole.log(Infinity === Number.POSITIVE_INFINITY) // trueconsole.log(Infinity &lt; 99999999999999999) // false 간단한 비교연산입니다. 어떤 큰 숫자가 오더라도 Infinite 보다 클 수는 없지요. 이것을 실제 코드에서 어떻게 활용할 수 있을까요? 어쩌다가 숫자비교를 작성하다보면 그런 순간이 옵니다. 이럴 경우에는 무조건 참을 반환해야하는데? 이건 무조건 거짓으로 판단해야하는데? 123if (modelCount() &gt; playCount()) &#123; // ...&#125; 예제의 modelCount()과 비교되는 숫자가 무엇이든 간에 참으로 판별해야하는 순간이 올 수 있습니다. 예를 들자면 modelCount()가 한정된 숫자의 제한이 없는, 무제한의 설정이 올 수 있는 순간이지요. 그럴 때 사용할 수 있는게 Infinite Number 입니다. 12345678function modelCount () &#123; var model = db.find('my_table') if (model.is_infinite) &#123; return Number.POSITIVE_INFINITY &#125; else &#123; return model.stock &#125;&#125; 이렇게 되면 playCount()가 아무리 억대의 숫자가 나오더라도, 무조건 참으로 판별할 수 있습니다. 1assert(INF &lt; 999999999); // =&gt; false php 에서는 INF 라는 상수로 Infinite Number를 사용할 수 있습니다.","categories":[],"tags":[]},{"title":"제스쳐 라이브러리 Hammer.js 에 대해 알아보자","slug":"hammerjs","date":"2017-10-31T13:38:26.000Z","updated":"2017-11-29T06:40:53.234Z","comments":true,"path":"2017/10/31/hammerjs/","link":"","permalink":"https://minukang.github.io/2017/10/31/hammerjs/","excerpt":"","text":"모바일이라는 한정된 뷰포트에서 사용자에게 다양한 정보를 제공하기 위해서 비주얼 영역에 Swiper 등의 라이브러리를 사용하곤 했습니다. 하지만 상대적으로 불필요한 기능을 다수 포함하고 있고, 마크업 / 클래스네이밍을 강제하고 있으며(물론 설정을 통해 클래스네임을 변경할 수 있습니다.), 커스터마이징이 어렵습니다. 무엇보다 많은 Swiper 요소가 있을 경우 자원을 굉장히 소모하고 있다는 것입니다. 그래서 기존에 슬라이드 만들던것처럼 단순히 제스쳐만 추가하여 슬라이드 기능을 할 수 없을까? 하다가 찾아낸것이 바로 Hammer.js 입니다. HammerJS 공식 홈페이지 Hammer.js 는 화려한 제스쳐 인터렉션이 아닌 단순히 제스쳐를 지정하고, 이벤트 리스너 형태로 사용할수 있도록 만든 라이브러리입니다. 다음의 코드를 보시면 이해하기 쉽습니다. 12var container = document.getElementById('container')var swiper = new Hammer(container) 먼저 DOM 엘리먼트를 지정하여 Hammer 객체의 인자로 넘깁니다. 1swiper.get('swipe').set(&#123; velocity: 0.3 &#125;) Hammer.prototype.get 으로 해당 제스쳐의 설정객체를 가져와 Hammer.prototype.set 메서드로 세부설정을 할 수 있습니다. velocity 옵션으로 얼마나 많은 움직임을 주었을때 스와핑할지 선언합니다. 범위는 0 ~ 1이고 기본값은 0.3 입니다. 0.5 로 지정할 경우 50%를 땡겨야 스와핑되는것을 의미합니다. 1swiper.get('swipe').set(&#123; direction: Hammer.DIRECTION_HORIZONTAL &#125;) direction 옵션으로 특정 방향만 제한할 수 있습니다. 12345678910swiper.on('swipe', function (e) &#123; switch (e.direction) &#123; case Hammer.DIRECTION_RIGHT: prev() break; case Hammer.DIRECTION_LEFT: next() break; &#125;&#125;) 활성화 후 Hammer 인스턴스에 이벤트를 등록할 수 있습니다. swipe 이벤트를 등록하게 되면 핸들러의 첫번째 인자인 이벤트 객체에 direction 을 받을 수 있습니다. 123456swiper.on('swipeleft', function (e) &#123; next()&#125;)swiper.on('swiperight', function (e) &#123; prev()&#125;) 혹은 swipeleft, swiperight 이벤트 등으로 분리하여 작성 할 수 있습니다. 완성본입니다. 스와이프를 통해서 슬라이드를 조작 할 수 있습니다.","categories":[],"tags":[]},{"title":"EYEYE","slug":"eyeye","date":"2017-10-30T07:24:30.000Z","updated":"2017-11-06T11:31:56.869Z","comments":true,"path":"2017/10/30/eyeye/","link":"","permalink":"https://minukang.github.io/2017/10/30/eyeye/","excerpt":"","text":"디자이너 계한희의 Directing으로2016 S/S 시즌 론칭하는 ‘EYEYE’는 화려하면서 위트 있는 패턴과 심플한 실루엣으로 믹스 앤 매치가 돋보이는 컨템포러리 여성복 브랜드입니다. 에이치나인에서 컨셉/기획/디자인을 담당하였고, 디앤디랩에서 퍼블리싱/개발을 맡았습니다. 2015년 12월에 시작하여 2016년 1월에 완료하였으며, 큰 특징으로 독창적인 레이아웃과 역동적인 인터렉션, 시시각각 변하는 비주얼 컬러를 꼽을 수 있습니다. EYEYE 디앤디랩 포트폴리오 현재는 다른 리뉴얼 디자인으로 오픈된 상태입니다. 수행목록PC 퍼블리싱 모바일 퍼블리싱 컬렉션 갤러리 게시판 개발 콜라보레이션 룩북 개발 뉴스레터 시스템 개발","categories":[],"tags":[]},{"title":"미누채팅","slug":"2013-minuchat","date":"2017-10-30T06:45:00.000Z","updated":"2017-11-06T11:30:55.930Z","comments":true,"path":"2017/10/30/2013-minuchat/","link":"","permalink":"https://minukang.github.io/2017/10/30/2013-minuchat/","excerpt":"","text":"미누채팅은 2013년 6월 ~ 2013년 7월동안 만든 웹 채팅 사이트입니다. 단순히 친구들과 채팅하고, 파일 공유를 하기 위해서 만들어졌습니다. 지원브라우저는 IE6 이상입니다. 또한 모바일에서도 레이아웃이 적용이 되도록하였습니다. 개발 코드적인 특징으로 jQuery 외 기타 라이브러리 없이 독자적으로 스크립트 라이브러리 Minuspace.js 를 만들어 jQuery를 흉내내어 구현했습니다. 위 사진의 $M 으로 되어 있는 부분이 Minuspace.js 입니다. Minuspace.js는 jQuery의 거의 대부분을 구현했습니다. CSS selector, animate 등을 직접 작성했습니다. 지금 생각해보면 좋은 오픈소스 라이브러리를 사용하지 않고 Minuspace.js를 만든것이 꽤나 무모한 짓이지만 고등학생 입장에서 많은 걸 배우게된 계기가 되었습니다. DOM의 동작원리를 이해하는데 중요한 계기가 되었음 jQuery 및 prototype 동작원리를 이해하게됨 크로스 브라우징을 배우게됨 애니메이션의 동작원리를 이해하게됨 서버사이드는 PHP로 작성하였습니다. 이것도 역시 고등학생의 무모함으로 외부 프레임워크 없이 직접 MVC 패턴을 구현하였습니다. 파일 업로드 기능을 붙이면서 채팅목록 가져오는 쿼리가 20초 걸린 이력도 있습니다. 또한 그 쿼리를 튜닝함으로써 0.1초로 줄여서 희열을 느낀 경험도 있습니다. 화면 스크린샷","categories":[],"tags":[]},{"title":"Flexbox 레이아웃에 대하여 알아보기","slug":"flex-display","date":"2016-07-18T05:34:25.000Z","updated":"2017-10-31T12:51:35.324Z","comments":true,"path":"2016/07/18/flex-display/","link":"","permalink":"https://minukang.github.io/2016/07/18/flex-display/","excerpt":"","text":"소개2009년에 만들어져 2011년에 다시 수정되고, 2013년에 최종적으로 개정된 Flexbox 레이아웃이 존재합니다. Flexbox를 사용하면 기존의 float과 inline-block, table 디스플레이는 감히 넘볼 수 없는 놀라운 레이아웃을 만들 수 있습니다. 하지만 이 놀라운 레이아웃 시스템을 왜 이용하지 않는 걸까요? 비교적 최근(2009년)에 초안이 만들어지다보니 그 전에 만들어진 브라우저는 지원을 하지 않습니다. 대표적으로 아직 대한민국에서 끈질기게 살아남고 있는 인터넷 익스플로러8 가 있습니다. 그러다보니 아직 현실적으로 서비스 페이지에서 배포하기엔 무리가 있습니다. 물론 하위 브라우저를 지원하지 않을 생각이라면 좋구요 :) Flexbox 레이아웃을 완벽히 지원하기 위해서 정리하자면 Flexbox 1버젼 (이하 오래된 Flexbox): 안드로이드 아이스크림 샌드위치(4.3) 이하, IOS 6이하 Flexbox 2버젼 (이하 MS Flexbox): 인터넷 익스플로러 10 Flexbox 3버젼 (이하 현재 Flexbox): 그 이상의 최신 브라우저 익스플로러 혼자…. 모바일은 지원률은 매우 좋습니다. 그렇다고 무작정 최신버젼으로 작성하면 약간 곤란합니다. 세 차례에 걸쳐서 수정이되다보니 버젼별로 문법이 상이합니다. 그래서 조금만 써도 vendor prefix에 하위버젼 지원하다보니 코드가 왕창 늘어납니다. 그리고 아직 생각보다 아이스크림 샌드위치 사용자가 꽤 있다고합니다. 아래의 스타일은 간단히 Flexbox 레이아웃을 사용한 일부분입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041.member-benefit--nav-item-anchor &#123; display: -webkit-box; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; -webkit-box-pack: center; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; -webkit-box-orient:vertical; -moz-box-orient:vertical; -webkit-flex-direction: column; -moz-flex-direction: column; -ms-flex-direction: column; -o-flex-direction: column; flex-direction: column; width: 6.2rem; height: 6.2rem; border: .1em solid #dcdbd9; border-radius: 50%; text-align: center; margin: auto; -webkit-transition: all 300ms; -o-transition: all 300ms; transition: all 300ms; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); -o-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&#125; 세상에… 하지만 그걸 감안하더라도 매우 매력적인 시스템입니다. 확신하건데, 브라우저의 파편화가 사라질꺼라 예상하는 10년내에 Flexbox 레이아웃 시스템은 주류로 잡을 것입니다. 그래서 이번 기회에 CSS 전처리기 중 하나인 SCSS를 이용한 예제로 Flexbox의 하위버젼을 지원하는 방법에 대해 정리해보았습니다. 개념정리 배우기 앞서 Flexbox 레이아웃을 사용하는 개념에 대해 알아두셔야합니다. Flexbox 레이아웃을 정의하기 위해서는 먼저 적용되는 개념을 알아야합니다. flexbox 라는 개념을 하나의 컨테이너(container)에 적용을 하면, 그 자식(item)들이 컨테이너의 속성에 따라 크기 및 위치가 자리 잡히게되는 원리입니다. 시작12345678910111213141516@mixin flex-display($inline: null) &#123; $box-display: if($inline == inline, inline-box, box); $flex-display: if($inline == inline, inline-flex, flex); display: -webkit- + $box-display; display: -ms- + $flex-display + box; display: -moz- + $flex-display; display: -ms- + $flex-display; display: -webkit- + $flex-display; display: $flex-display;&#125;.flex-box &#123; @include flex-display();&#125;.flex-inlinebox &#123; @include flex-display(inline);&#125; 우선 Flexbox 를 사용하기 위해서 요소의 display를 특별한 값으로 선언해야합니다. 오래된 버젼에서는 box 라는 값을 사용했습니다. MS버젼에서는 flexbox라는 이름을 사용하였고, 최종적으로 flex로 정해져 사용합니다. Flexbox 와 관련된 내용을 사용하기 위해서는 반드시 지정해야합니다. 또한 display: inline-flex 형태로 요소를 inline 처럼 사용하여 적재적소에 사용할 수 있습니다. 자식 요소들의 방향지정123456789101112131415@mixin flex-direction ($direction:row) &#123; $old-value: if(str-index($direction, column), vertical, horizontal); -moz-box-orient: $old-value; -webkit-box-orient: $old-value; -ms-flex-direction: $direction; -webkit-flex-direction: $direction; flex-direction: $direction; @if str-index($direction, '-') &#123; -moz-box-direction: reverse; -webkit-box-direction: reverse; &#125;&#125; Flexbox는 기본적으로 Table처럼 단순히 왼쪽에서 오른쪽으로 흐르게 하지만, Flexbox 컨테이너에 flex-direction 을 통하여 현재 흐르는 순서를 상하좌우 네 방향으로 바꿀 수 있습니다. flex-direction은 기본적으로 row 값을 가지게됩니다. 자식들을 좌에서 우로 흐르게합니다. row-reverse 은 자식들을 우에서 좌로 흐르게 합니다. column 은 자식들을 위에서 아래로 흐르게 합니다. 자식들은 flex 값을 통해 너비가 아닌 높이를 계산하게 됩니다. column-reverse 는 자식들을 아래에서 위로 흐르게 합니다. 방향만 제외하면 column 과 같습니다. 오래된 Flexbox에서는 box-orient 속성을 통해 자식들을 좌에서 우 혹은 위에서 아래로 흐르게 할 수 있습니다.box-direction은 단순히 방향 역전 속성으로, reverse 값을 지정함으로써 역전할 수 있습니다. 자식요소들의 묶음 여부123456789// nowrap, wrap@mixin flex-wrap ($wrap: nowrap) &#123; $old-wrap: if($wrap == wrap, multiple, single); -webkit-box-lines: $old-wrap; -moz-box-lines: $old-wrap; -ms-flex-wrap: $wrap; -webkit-flex-wrap: $wrap; flex-wrap: $wrap;&#125; Flexbox 레이아웃은 컨테이너의 자식들을 주어진 방향대로 한줄로만 보여지는 특성이 있습니다. 그래서 자식 요소들의 합친 너비가 컨테이너의 너비보다 커도 컨테이너가 묶여있지않아 한줄로만 보여지게되는 것입니다. 이를 풀어진 상태라고 말합니다.flex-wrap 속성을 사용하여 이 풀어진 상태를 해제할 수 있습니다. 기본값은 풀어진 상태인 nowrap 입니다. wrap 값으로 지정하면 컨테이너의 너비가 묶이게 되어 자식요소들이 정해진 크기만큼 여러줄 배치할 수 있게됩니다. 오래된 Flexbox 에서는 box-lines 라는 이름으로 사용합니다. 이름 그대로 single 값은 자식요소들을 한줄에만 표시하며, multiple 은 자식요소들을 여러 줄로 보여진다고 해석하시면됩니다. 방향과 묶음을 한번에 지정1234@mixin flex-flow ($direction: row, $wrap: nowrap) &#123; @include flex-direction($direction); @include flex-wrap($wrap);&#125; flex-flow 는 일종의 alias로, flex-direction과 flex-wrap을 한 번에 지정할 수 있습니다. 자식요소들의 상하 정렬12345678910111213// stretch, flex-start, flex-end, center@mixin flex-align-items ($style:stretch) &#123; $old-style: $style; $str-index: str-index($style, '-'); @if $str-index &#123; $old-style: str-slice($style, $str-index + 1); &#125; -webkit-box-align: $old-style; -moz-box-align: $old-style; -ms-flex-align: $old-style; -webkit-align-items: $style; align-items: $style;&#125; 예전부터 상하정렬은 애증의 대상이었습니다. 이제는 Flexbox 레이아웃을 통하여 간단하게 상하정렬을 자유롭게 지정할 수 있습니다. align-items 속성을 이용하여 자식요소들의 상하정렬을 어떻게 할지 설정할 수 있습니다. 기본값은 strecth 입니다. strecth 값은 자식요소들을 무조건 Flexbox 컨테이너의 높이만큼 크기를 잡아줍니다. flex-start 값은 자식요소들을 Flexbox 컨테이너의 상하 시작 방향에 붙여 정렬합니다. flex-end 값은 자식요소들을 Flexbox 컨테이너의 상하 끝 방향에 붙여 정렬합니다. basline 값은 자식요들을 Flexbox 컨테이너의 상하 시작 방향에 정렬하지만, 컨텐츠의 바닥을 기준으로 정렬됩니다. center 값은 자식요소들을 Flexbox 컨테이너의 중앙에 정렬합니다. 오래된 Flexbox에서는 flex-start와 flex-end 대신 start와 end로 사용합니다. 눈여겨볼것은 center 값을 사용하여 요소를 정가운데 놓이게 할 수 있습니다. 이로써 컨텐츠 크기도 보존하면서 자유롭게 배치할 수 있게 되었습니다. flex-direction 을 통해서 순서가 상하로 지정할 경우 자식요소의 좌우정렬을 하는 것에 유의해주세요. 자식요소들의 좌우 정렬12345678910111213141516171819202122// flex-start, flex-end, center, space-between, space-around@mixin flex-justify-content ($justify:flex-start) &#123; // ms justify $ms-justify: $justify; @if $justify == flex-start &#123; $ms-justify: start; &#125; @else if $justify == flex-end &#123; $ms-justify: end; &#125; @else if $justify == space-between &#123; $ms-justify: justify; &#125; @else if $justify == space-around &#123; $ms-justify: distribute; &#125; // old justify $old-justify: if($ms-justify == distribute, justify, $ms-justify); -webkit-box-pack:$old-justify; -moz-box-pack:$old-justify; -ms-flex-pack:$ms-justify; -webkit-justify-content: $justify; justify-content: $justify;&#125; justify-content 속성을 이용하여 자식요소들의 좌우정렬을 어떻게 할지 설정할 수 있습니다. 기본값은 없습니다. flex-start 값은 자식요소들을 Flexbox 컨테이너의 좌우 시작방향에 붙여 정렬합니다. flex-end 값은 자식요소들을 Flexbox 컨테이너의 좌우 끝방향에 붙여 정렬합니다. center 값은 자식요소들을 Flexbox 컨테이너의 중앙에 정렬합니다. space-between 값은 자식요소들을 같은 공백을 주어진채로 정렬합니다. 첫번째 자식요소와 마지막 자식요소는 각각 시작과 끝에 배치됩니다. space-around 값은 자식요소들을 같은 공백을 주어진채로 정렬합니다. space-between과 다른점은 시작과 끝에도 공백이 주어집니다. 오래된 Flexbox에서는 box-pack이라는 값을 사용합니다. flex-start와 flex-end 대신 start와 end로 사용합니다. space-between 값은 justify 라는 값으로 사용합니다. space-around는 오래된 Flexbox에서 지원을 안합니다. MS Flexbox는 flex-pack이라는 속성을 사용하며, 오래된 Flexbox와 쓰이는 값은 값은 같지만 space-around를 distribute라는 값으로 사용합니다. flex-direction 을 통해서 순서가 상하로 지정할 경우 자식요소의 상하정렬을 하는 것에 유의해주세요. 묶음을 풀어버린 자식요소들의 여백정렬 조정1234567891011121314151617// stretch, flex-start, flex-end, center, space-between, space-around@mixin flex-align-content ($align: strecth) &#123; // ms align $ms-align: $align; @if $align == flex-start &#123; $ms-justify: start; &#125; @else if $align == flex-end &#123; $ms-justify: end; &#125; @else if $align == space-between &#123; $ms-justify: justify; &#125; @else if $align == space-around &#123; $ms-justify: distribute; &#125; -ms-flex-line-pack: $ms-align; -webkit-align-content: $align; align-content: $align;&#125; align-content 속성은 단독으로 사용할 수 없습니다. flex-wrap 으로 wrap 상태에서 자식요소들이 여러줄에 걸쳐 나와야 사용할 수 있습니다. 이 속성은 그 줄과 줄 사이에 간격을 정렬을 해주는 역할을 합니다. stretch 값은 기본값으로, 자식그룹과 자식그룹의 크기를 여백없이 똑같이 가져가게 합니다. flex-start 값은 자식그룹을 위에서 부터 배치합니다. flex-end 값은 자식그룹을 아래에서 부터 배치합니다. center 값은 자식그룹들을 가운데 부터 배치합니다. space-between 값은 자식그룹들을 같은 공백을 주어진채로 정렬합니다. 첫번째 자식그룹과 마지막 자식그룹은 각각 시작과 끝에 배치됩니다. space-around 값은 자식그룹들을 같은 공백을 주어진채로 정렬합니다. space-between과 다른점은 시작과 끝에도 공백이 주어집니다. MS Flexbox는 flex-start와 flex-end 대신 start와 end로 사용합니다. space-between 값은 justify 라는 값으로 사용합니다. 그리고 space-around를 distribute라는 값으로 사용합니다. 이 속성은 Flexbox 버젼2와 최신버젼에서만 사용할 수 있으며, 오래된 버젼에서는 사용할 수 없음을 유의해주시길 바랍니다. 자신의 흐르는 순서 지정1234567@mixin flex-order ($order: 0) &#123; -webkit-box-ordinal-group: $order; -moz-box-ordinal-group: $order; -ms-flex-order: $order; -webkit-order: $order; order: $order;&#125; Flexbox의 놀라운 기능 중 하나로, 자식 요소들의 HTML 상의 순서가 아닌 CSS만으로 이들의 순서를 바꿀 수 있습니다. 이로써 DL&gt;DT+DD 와 같이 의미 있는 요소들을 문서에 맞게 사용한 후 순서를 바꾸어 디자인을 고려할 수 있습니다. 더욱 더 문서는 문서에 집중 할 수 있는 웹 표준에 부합하는 기능이라 볼 수 있습니다. 자식요소에 부여하는 속성으로, 이 속성은 순서를 배치하고자하는 숫자를 입력할 수 있습니다. 2를 설정할 경우 자식요소 중에서 2번째에 배치되며, 4로 설정할 경우 자식요소 중에서 4번째에 배치됩니다. 또한 음수값도 지원하여 양수보다 우선도를 더 높일 수 있습니다. 오래된 Flexbox의 경우 정수만을 지원하여 음수값(-1) 을 사용 할 수 없습니다. 자신의 독립적인 정렬12345678910// flex-start, flex-end, center, baseline, stretch, auto@mixin flex-align-self ($style: strech) &#123; $style-index: str-index($style, '-'); $old-style: if($style-index, str-slice($style, $style-index + 1), $style); -webkit-box-align: $old-style; -moz-box-align: $old-style; -ms-flex-item-align: $old-style; -webkit-align-self: $style; align-self: $style;&#125; flex-align-items 을 단독으로 사용 할 수 있는 속성입니다. 자식요소에 부여하며, 부여 시 다른 자식요소들과 상관없이 방향정렬이 단독으로 이루어집니다. 이 속성은 Flexbox 버젼2와 최신버젼에서만 사용할 수 있으며, 오래된 버젼에서는 사용할 수 없음을 유의해주시길 바랍니다. 공간 만들기123456789101112131415@mixin flex($number: 1) &#123; -webkit-box-flex: $number; -moz-flex: $number; -ms-flex: $number; -webkit-flex: $number; flex: $number; width: $number * 100%;&#125;.flex-item &#123; @include flex(1);&#125;.flex-item.__flex2__ &#123; @include flex(2);&#125; flex 속성은 flex-grow, flex-shrink, flex-basis 를 축약으로 쓸 수 있는 Alias입니다. 하지만 오래된 Flexbox에서는 flex-shrink와 flex-basis를 지원하지 않습니다. 오래된 Flexbox에서는 box-flex라는 속성으로 flex-grow에 매칭합니다. 이하 설명은 flex-grow입니다. flex 속성은 컨테이너가 아닌 자식에 사용되는 속성입니다. 기본적으로 모든 Flexbox 컨테이너의 자식은 0으로 지정되어 있습니다. 이 속성을 적용하게 되면, flex 값이 0인 형제들의 크기를 제외하고 컨테이너의 나머지 공간을 차지하게됩니다. 1 이상인 자식들의 flex 값을 모두 합친 뒤, 합친 숫자의 각각의 flex 숫자만큼의 비율만큼 차지하게 되는 것입니다. 예로, 모든 자식의 flex가 1일 경우, 모든 자식은 똑같은 영역의 크기를 가지게됩니다.flex가 2고, flex가 1인 자식이 있을 경우, 2는 75%의 크기를, 1은 25%의 크기를 가지게됩니다. 오래된 Flexbox에서는 box-flex 형태로 사용하게됩니다. 그런데 오래된 모바일에는 버그가 있는지 컨텐츠의 내용에 따라 제대로 크기를 잡아주지 못합니다. 그래서 box-flex의 값의 100% 를 곱한만큼 width 를 사용하면 이 문제를 해결할 수 있습니다. 최신 브라우저에서는 flex 값이 정해지면 width 의 영향을 받지 않기 때문에 해결책이라 볼 수 있습니다.","categories":[],"tags":[]}]}